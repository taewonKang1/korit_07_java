

# Object 클래스
- 모든 클래스는 Object 클래스를 상속 받는다. 그래서 interface를 implement할 때나 다른 sub 클래스 만들어서 extends명령어 입력했을 때 우리가 직접 만들었던 슈퍼 클래스 이외에 toString() 어쩌고 한 것들이 있었습니다.
    1. toString() : 기본적으로 모든 클래스는 Object 클래스를 상속 받아서, 클래스 이름과 해시코드(일종의 주소지 개념)를 return함.
        - 이를 Override해서 재정의하여 클래스의 정보를 출력할 때 사용함.
        - ObjectTest / ObjectTestMain 클래스 작성
        - 필드를 정의하고, toString() 메서드를 override해서 필요한
            필들르 출력함 -> Main 단계에서 특정 객체의 필드를 객체의 이름만으로 출력이 가능함.(sout(객체명);으로 가능 / sout(객체명.showInfo())가 아니라.)

    2. equals() : 두 객체가 '논리적으로 같은지'를 비교하는 메서드(주소지의 차이가 아니라). 기본적으로 Object 클래스의 equals() 메서드는 두 객체의 참조 주소를 비교합니다.
        - 형식 : 객체명1.equals(객체명2) -> 객체명1과 객체명2의 참조 주소가 동일한지 확인함. - 3형식 문장으로 해석하시면 됩니다. SVO.
    
    3. hashCode() : 객체를 정수 값(해시값)으로 변환(16진수가 아니라). 해시값은 주로 해시 기반 컬렉션에서 사용됩니다(추후 수업 에정).
        - equals() 메서드를 재정의하게 되면 반드시 hashCode() 메서드도 재정의해야만합니다. 왜냐면 동일한 객체(equals == true)는 동일한 해시 코드를 가져야하기 때문인데, 문제는 해시 코드가 같다고 해서 또 equals()가 true가 아닌 경우가 있습니다.

# Lombok
메뉴바(햄버거) -> 설정 -> 좌측에 plugins(플러그인) 선택 -> Lombok 검색 -> 설치 후 disabled/비활성화 라고 나와있으면 활성화된 상태라는 뜻입니다.

chrome -> maven repositories로 들어가서 lombok 검색 -> 웬만하면 최신 버전
그래고 저희는 빌드 시스템이 gradle이기 때문에(그리고 코틀린이 아니기 때문에), groovy short로 복사
그리고 annotationProcessor도 꼭 적용해야 합니다.

```
dependencies {
    implementation 'org.projectlombok:lombok:1.18.38'
    testImplementation platform('org.junit:junit-bom:5.10.0')
    testImplementation 'org.junit.jupiter:junit-jupiter'
    annotationProcessor 'org.projectlombok:lombok:1.18.38'
}
```
이상과 같이 작성되어야 합니다.(이렇게 해두면 깃허브에 올라가니까 나중에 복사해서 쓰자)

# Lombok 주요 annotation
1. @Getter / @Setter
    - class level에 작성할 경우 getter / setter 메서드를 자동 생성.
    - field level에 작성할 경우 해당 필드에만 메서드 생성
    - 주의 : 객체마다 다른 값을 갖게 되는 비정형(non-static) 필드에 대해서만 적용됨.

```java
@Setter
@Getter
public class Person {
    private String name;
    private int age;
}
```

2. @ToString
    - toString() 메서드를 자동으로 생성. 근데 문제는 재정의가 안되고 Lombok 라이브러리 default 형태만 튀어나오기 때문에 결과적으로 원하는 부분만 보여주기 위해서 override methods(alt + ins)를 쓰는 경우가 많을 겁니다.

3. @EqualsAndHashCode
    - equals() / hashCode() 메서드를 자동 생성. 객체의 동일성 비교 로직을 구현할 때 사용
        - 아까 배웠던 것처럼 equals()를 재정의하면 hashCode()도 반드시 같이 재정의해야하기 때문에 에너테이션도 세트로 묶여있습니다.

4. @NoArgsConstructor / @RequiredArgsConstructor / @AllArgsConstructor
    - @NoArgsConstructor : argument가 없는 기본 생성자를 생성
    - @RequiredArgsConstructor : final 또는 `@NonNull` 에너테이션이 붙은 필드만 필수적으로 요구하는 매개변수 생성자를 생성
    - @AllArgsConstructor : 모든 필드를 argument로 요구하는 매개변수 생성자
```java
@NoArgsConstructor
@RequriedArgsConstructor
@AllArgsConstructor
public class Person {
    @NonNull
    private String name;
    private int age;
}

public class PersonMain {
    public static void main(String[] args) {
        Person person1 = new Person();      // 기본 생성자
        Person person2 = new Person("김이");  // name을 요구하는 매개변수 생성자
        Person person3 = new Person("김삼", 20);  // AllArgsConstructor
    }
}
```

4. @Data
    - @Getter / @Setter / @ToString / @EqualsAndHashCode / @RequiredArgsConstructor가 다 들어가있는 종합 패키지 애너테이션입니다. 그래서 제일 많이 쓰입니다.

그러다보니까 수강생들이 클래스 만들 때 제일 먼저 하는 방식 :
```java
@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Student extends Person {
    private String name;
    private int age;
    private double score;
}
```

5. @Builder - 추후 수업 예정

ch18_static

# Static

## 정의
- 클래스 수준에서 변수를 정의하거나 메서드를 선언할 때 사용
- static으로 선언된 변수나 메서드는 클래스의 '인스턴스에 속하지 않음.' (해당 클래스의 인스턴스가 전부 동일한 값을 공유함을 의미합니다)
- 클래스 자체에 속하게 됨.
- 이는 인스턴스를 생성하지 않고 접근이 가능하다는 점에서 일반적인 필드, 메서드와 구분 됩니다.